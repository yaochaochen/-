# 队列在源码方面的面试题

## 面试题

### 说说对队列的理解，队列和集合的区别

答: 对队列的理解

1. 首先队列本身也是容器，底层会有不同的数据结构，比如 LinkedBlockingQueue 的底层是链表结构，所以可以维持先入先出的顺序，比如 DelayQueue 底层是队列和堆栈，所以可以保证先入先出或者先入后出的顺序。底层的数据结构不同，也可以造成操作实现不同；
2. 部分队列（LinkedBlockingQueue）提供了暂时存储的功能，我们可以往队列里放数据，同时也可以从队列里面拿数据，两者可以同时进行；
3. 队列把生成数据的一方和消费一方进行解耦，生成者只管生产，消费者只管消费，两者间没有必然你的联系，队列就像生产者和消费者之间的数据通道一样。
4. 队列还可以对消费者和生产者进行管理，比如队列满了，有生产者还不停的投递数据时，队列可以使生产者阻塞住，让其不再投递，比如队列为空时，有消费者过来消费数据，队列也可以让消费者holder住，等有数据时，唤醒消费者
5. 队列也提供了阻塞功能

**和集合的区别**

1. 部分队列和部分集合底层的存储结构很类似，单两者为了完成不同的事情，提供的API和其底层的操作实现是不同的
2. 队列提供了阻塞功能，对消费者和生产者进行管理，队列为空时，会阻塞消费者，有其他线程进行put操作后，会唤醒阻塞的消费者，让消费者拿数据进行消费，队列满时也是一样的。
3. 解耦了生产者和消费者，队列就像是生产者和消费者之间的管道，两者只见那相互不关心。

### 那些队列具有阻塞的功能，如何阻塞的

1. LinkedBlockingQueue 链表阻塞 队列和 ArrayBlockingQueue 数组阻塞队列时一类的，前者容量时Integer的最大值，后者数组 大小是固定的，两个阻塞队列都可以指定容量大小，当队列满时，如果有线程 put 数据，线程会阻塞住，直到有其他线程进行消费数据后，才会唤醒阻塞线程继续 put ，当队列为空时，如果有线程 take 数据，线程会阻塞到队列不空时， 继续 take 

2. SynchronousQueue 同步队列，当线程 put 时，必须有对应线程把数据消费掉， put 线程才能返回，当线程 take 时，需要对线程进行 put 数据时， take 才能返回，反之阻塞。

   ### LinkedBlockingQueue 和 ArrayBlockingQueue 有啥区别

   **相同点:**

   1. 两者阻塞机制大体相同，比如队列满，空时，线程都会阻塞

   **不同点:**

   1. LinkedBlockingQueue 底层是链表结构，容量默认值是 Integer 最大值 ArrayBlockingQueue 底层是数组，容量必须在初始化时指定
   2. 两者  底层数据结构不同，所有 take  put remove底层实现不同

### 往队列里面放入 put 数据是线程安全的么？为什么？

是线程安全的，在put之前，队列会自动加锁，put完成后 锁会自动释放，保证了同一时刻只会有一个线程能操队列数据， LinkedBlockingQueue 为例，put 时，会 put 加锁，并且只对 tail 进行操作，take时，会take加锁，只对head进行 remove 会同时 put 和 take 锁，所以各种操作都是线程安全的。

### take 操作会加锁吗？ 既然put和take都同时加锁，是不是同一时间只能运行其中一个方法

是的，

1.  take 时会加锁，就像 LinkedBlockingQueue在执行 take 方法时，在拿数据的同时，会把当前数据删除掉，就改变了链表 的数据结构，所有需要加锁保证线程安全
   
2. 对于 LinkedBlockingQueue来说，队列 put 和 take 会加锁，单两者的锁是不一样的，所以两者互不影响，可以同时进行的，对于ArrayBlockQueue而言， put 和 take 是同一个锁，所以只能运行一个方法

### 把数据放入队列中后，有没有办法让队列过去一会再执行

可以的，DelayQueue听过这种机制，但是缺点是数据保存在内存里，容易丢失，但是可以采取延迟队列中间件进行实现。

### DelayQueue 对元素有什么要求，我把String 放到队列中去可以么？

DelayQueue 要求元素必须实现 Delay接口， Delayed本身又实现了Comparable 接口 Delayed 接口作用是定义还剩多久就会超时，Comparable 接口主要哦用于元素之前的超时时间进行排序，这样做的话快过期的元素能够排到前面。

所以String放到DelayQueue 中是不行的，编译都无法通过，DelayQueue 类在定义的时候，是有泛型定义的 泛型必须是Delay接口的子类才能够。

